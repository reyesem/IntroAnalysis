"0","boot_pairwise <- 
  function(orig.model, null.model = NULL, n.boot.reps = 1000, group.var = NULL){
    require(tidyverse, quietly = TRUE)
    require(modelr, quietly = TRUE)
    require(broom, quietly = TRUE)
    
    # Bootstrap for Confidence Intervals
    if(is.null(null.model)){
      if(is.null(rlang::f_rhs(rlang::enquo(group.var)))){
        # obtain the original dataset
        .orig.df <- suppressWarnings(augment(orig.model))
        
        # bootstrap
        .boot.df <- .orig.df %>%
          modelr::bootstrap(n = n.boot.reps, id = \"replicate\")
        
        # fit models
        out.df <- 
          purrr::map(.boot.df$strap, ~ update(orig.model, data = .)) %>%
          map_df(., broom::tidy, .id = \"replicate\")
        
      }else{
        
        .orig.df <- suppressWarnings(augment(orig.model))
        .orig.df <- group_by(.orig.df,
                             !!rlang::enquo(group.var))
        
        .boot.df <- .orig.df %>%
          do(bootstrap(., n = n.boot.reps)) %>%
          group_by(.id)
        
        out.df <- .boot.df %>%
          do({
            do.call(rbind, map(.$strap, as_data_frame)) %>%
              update(orig.model, data = .) %>%
              tidy()
          }) %>%
          rename(replicate = .id)
      }
      
    }
    
    # Bootstrap for p-values
    if(!is.null(null.model)){
      if(is.null(rlang::f_rhs(rlang::enquo(group.var)))){
        # obtain the fitted values under the null
        .null.df <- suppressWarnings(augment(null.model))
        
        # obtain the original dataset but replace the fitted values with those
        #  under the null and create new \"original responses\"
        .orig.df <- suppressWarnings(augment(orig.model)) %>%
          mutate(.fitted = .null.df$.fitted,
                 .newy = .fitted + .resid)
        
        # bootstrap
        .boot.df <- .orig.df %>%
          modelr::bootstrap(n = n.boot.reps, id = \"replicate\")
        
        # fit models
        #  both null and alternative models are fit with new data and 
        #  anova() is used to compute the statistic testing the two models.
        out.df <- 
          purrr::map(.boot.df$strap, function(df){
            h1 <- update(orig.model, .newy ~ ., data = df)
            h0 <- update(null.model, .newy ~ ., data = df)
            
            anova(h0, h1)
          }) %>%
          map_df(., broom::tidy, .id = \"replicate\")
        
      }else{
        
        .null.df <- suppressWarnings(augment(null.model))
        .orig.df <- suppressWarnings(augment(orig.model)) %>%
          mutate(.fitted = .null.df$.fitted,
                 .newy = .fitted + .resid)
        .orig.df <- group_by(.orig.df,
                             !!rlang::enquo(group.var))
        
        .boot.df <- .orig.df %>%
          do(modelr::bootstrap(., n = n.boot.reps)) %>%
          group_by(.id)
        
        out.df <- .boot.df %>%
          do({
            df <- do.call(rbind, map(.$strap, as_data_frame))
            h1 <- update(orig.model, .newy ~ ., data = df)
            h0 <- update(null.model, .newy ~ ., data = df)
            
            anova(h0, h1) %>%
              tidy()
          }) %>%
          rename(replicate = .id)
      }
      
      # remove extraneous lines from anova() output
      out.df <- out.df %>%
        filter(!is.na(statistic))
      
    }
    
    as_data_frame(out.df)
  }"
