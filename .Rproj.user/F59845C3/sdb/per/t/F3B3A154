{
    "collab_server" : "",
    "contents" : "#' @describeIn compare_models Computes p-value comparing nested linear models.\n#'\n#' @inheritParams compare_models\n#' @param assume.constant.variance boolean; if \\code{TRUE}, homoskedasticity is\n#' assumed for the error term. If \\code{FALSE} (default), this is not assumed.\n#' @param assume.normality boolean; if \\code{TRUE}, the errors are assumed to\n#' follow a Normal distribution. If \\code{FALSE} (default), this is not\n#' assumed.\n#' @param bootstrap.replications scalar indicating the number of bootstrap\n#' replications to use (default = 4999).  This is ignored if both\n#' \\code{assume.constant.variance = TRUE} and\n#' \\code{assume.normality = TRUE}.\n#' @param construct string defining the type of construct to use when generating\n#' from the distribution for the wild bootrap (see \\code{\\link{rmammen}}). If\n#' \\code{assume.constant.variance = TRUE}, this is ignored\n#' (default = \\code{\"normal-2\"}).\n#'\n#' @import stats\n#' @export\ncompare_models.lm <- function(full.mean.model,\n                              reduced.mean.model,\n                              assume.constant.variance = FALSE,\n                              assume.normality = FALSE,\n                              bootstrap.replications = 4999,\n                              construct = c(\"normal-2\",\n                                            \"normal-1\",\n                                            \"two-point mass\")){\n\n  if (any(class(full.mean.model) != class(reduced.mean.model))){\n    stop(\"Both the full and reduced models must be linear models.\")\n  }\n\n  if (!is.null(reduced.mean.model$offset) && assume.normality &&\n      !assume.constant.variance){\n\n    warning(paste(\"White-Huber estimator cannot be used with offset term.\",\n                  \"Recommend using linearHypothesis() within the car\",\n                  \"package. Continuing while imposing constant variance.\"))\n\n    assume.constant.variance <- TRUE\n  }\n\n  if (assume.normality && assume.constant.variance){\n    .anova <- my_anova(reduced.mean.model, full.mean.model)\n\n    .boot <- rf(bootstrap.replications, df1 = .anova$df[1], df2 = .anova$df[2])\n  } else if (assume.normality && !assume.constant.variance){\n    .anova <- my_anova(reduced.mean.model, full.mean.model)\n\n    .namesh0 <- names(reduced.mean.model$coefficients)\n    .namesh1 <- names(full.mean.model$coefficients)\n\n    if (!all(is.element(.namesh0, .namesh1))){\n      stop(\"Models are not nested.\")\n    }\n\n    .K <- diag(length(.namesh1))[!(.namesh1 %in% .namesh0),, drop = FALSE]\n    .test <- car::linearHypothesis(full.mean.model, .K, white.adjust = \"hc0\")\n\n    .anova$statistic[1] <- .test$F[2]\n    .anova$p.value[1] <- .test$`Pr(>F)`[2]\n\n    .boot <- rf(bootstrap.replicationss, df1 = .anova$df[1], df2 = .anova$df[2])\n\n  } else {\n    .boot <- bootstrap_residual_null(full.mean.model,\n                                     reduced.mean.model,\n                                     reps = bootstrap.replications,\n                                     wild = !assume.constant.variance,\n                                     construct = construct)\n\n    .anova <- bootstrap_compute_p(.boot)\n  }\n\n  attr(.anova, \"Null Distribution\") <- as.numeric(.boot)\n  .anova\n}\n\n\n\n#' @describeIn compare_models Computes p-value comparing nested generalized\n#' linear models.\n#'\n#' @inheritParams compare_models\n#' @param method string defining the methodology to employ. If\n#' \\code{\"classical\"} (default), the model is assumed correct and classical\n#' large-sample theory is used. If \\code{\"parametric\"}, a parametric bootstrap\n#' is performed.\n#' @param bootstrap.replications scalar indicating the number of bootstrap\n#' replications to use (default = 4999).  This is ignored if\n#' \\code{method = \"classical\"}.\n#'\n#' @import stats\n#' @export\ncompare_models.glm <- function(full.mean.model,\n                               reduced.mean.model,\n                               method = c(\"classical\",\n                                          \"parametric\"),\n                               bootstrap.replications = 4999){\n\n  if (any(class(full.mean.model) != class(reduced.mean.model))){\n    stop(\"Both the full and reduced models must be linear models.\")\n  }\n\n  if (method == \"classical\"){\n    .knownvar <- is.element(full.mean.model$family$family,\n                            c(\"binomial\", \"poisson\"))\n\n    .anova <- my_anova(reduced.mean.model, full.mean.model,\n                       test = ifelse(.knownvar, \"Chisq\", \"F\"))\n\n    if (.knownvar){\n      .boot <- rchisq(bootstrap.replications, df = .anova$df[1])\n    } else {\n      .boot <- rf(bootstrap.replications,\n                  df1 = .anova$df[1],\n                  df2 = .anova$df[2])\n    }\n  } else if (method == \"parametric\"){\n    .boot <- bootstrap_parametric_null(full.mean.model,\n                                       reduced.mean.model,\n                                       reps = bootstrap.replications)\n\n    .anova <- bootstrap_compute_p(.boot)\n  }\n\n  attr(.anova, \"Null Distribution\") <- as.numeric(.boot)\n  .anova\n}\n\n",
    "created" : 1528731917169.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2183690329",
    "id" : "F3B3A154",
    "lastKnownWriteTime" : 1528751712,
    "last_content_update" : 1528751712374,
    "path" : "C:/Users/Administrator/OneDrive - Rose-Hulman Institute of Technology/Github/IntroAnalysis/R/compare_models.R",
    "project_path" : "R/compare_models.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}