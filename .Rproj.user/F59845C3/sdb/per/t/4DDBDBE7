{
    "collab_server" : "",
    "contents" : "#' Perform (optionally wild) residual bootstrap for linear model.\n#'\n#' This is the workhorse for the \\code{estimate_parameters()} function when a\n#' linear model is specified. Given a linear model fit, performs a residual\n#' bootstrap (or optionally wild bootstrap) to estimate the standard error of\n#' and compute confidence intervals for each of the parameters in the model.\n#' This is not meant to be called by the user directly.\n#'\n#' @param fit \\code{lm} object defining the model for which the parameters are\n#' estimated.\n#' @param reps scalar; number of bootstrap replications to perform.\n#' @param wild boolean; if \\code{TRUE}, a wild bootstrap is performed. If\n#' \\code{FALSE} a traditional residual bootstrap is performed.\n#' @param construct string defining the type of construct to use when generating\n#' from the distribution for the wild bootrap (see \\code{\\link{rmammen}}). If\n#' \\code{wild = FALSE}, this is ignored.\n#'\n#' @return matrix with the same number of rows as coefficients in \\code{fit} and\n#' \\code{reps} columns. Each row contains the bootstrap estimates of the\n#' corresponding parameters.\n#'\n#' @examples\n#' \\dontrun{\n#' test.df <- data.frame(x = seq(10), y = seq(10) + rnorm(10))\n#' fit <- lm(y ~ x, data = test.df)\n#' bootstrap_residual(fit, reps = 4999, wild = FALSE)\n#' }\n#'\n#' @import stats\nbootstrap_residual <- function(fit,\n                               reps,\n                               wild,\n                               construct){\n\n  .resid <- fit$residuals\n  .n <- length(.resid)\n\n  # obtain (X'X)^(-1) X'\n  .H <- qr.coef(fit$qr, diag(.n))\n\n  if (wild){\n    # obtain new residuals through multiplication by random variable\n    .bootr <- matrix(rmammen(.n*reps, construct = construct),\n                     nrow = .n, ncol = reps) * .resid\n  } else {\n    # obtain new residuals through resampling of original residuals\n    .bootr <- matrix(sample(.resid, size = .n*reps, replace = TRUE),\n                     nrow = .n, ncol = reps)\n  }\n\n  # compute estimates\n  .ests <- fit$coefficients + (.H %*% .bootr)\n\n  # compute standard errors\n  .sse <-\n    matrix(colSums(.bootr * .bootr) -\n             colSums(.bootr * (qr.Q(fit$qr) %*% t(qr.Q(fit$qr)) %*% .bootr)),\n           nrow = nrow(.ests), ncol = ncol(.ests), byrow = TRUE)\n\n  .stderrs <- sqrt(diag(chol2inv(qr.R(fit$qr))) * (.sse/fit$df.residual))\n\n  attr(.ests, \"std.err\") <- .stderrs\n  attr(.ests, \"original.estimates\") <- fit$coefficients\n  attr(.ests, \"original.std.err\") <- sqrt(diag(vcov(fit)))\n\n  .ests\n}\n\n\n\n#' Perform parametric bootstrap for linear models without constant variance.\n#'\n#' This is a workhorse function which performs a parametric bootstrap without\n#' assuming constant variance. This is not meant to be called by the user\n#' directly.\n#'\n#' @param fit \\code{lm} object defining the model for which the parameters are\n#' estimated.\n#' @param reps scalar; number of bootstrap replications to perform.\n#'\n#' @return matrix with the same number of rows as coefficients in \\code{fit} and\n#' \\code{reps} columns. Each row contains the bootstrap estimates of the\n#' corresponding parameters.\n#'\n#' @examples\n#'\n#' @import stats\nbootstrap_noniid_parametric <- function(fit,\n                                        reps){\n\n  # obtain parametric bootstraps\n  .resid <- fit$residuals\n  .n <- length(.resid)\n  .yat <- fit$fitted\n  if (!is.null(.offset <- fit$offset)) .yhat <- .yhat + .offset\n\n  .boot <- matrix(rnorm(reps * .n, mean = .yhat, sd = abs(.resid)),\n                  nrow = .n, ncol = reps)\n\n  # construct original data\n  if (is.null(getCall(fit)$data)){\n    .data <- attr(fit$terms, \".Environment\")\n  } else {\n    .data <- get(paste(getCall(fit)$data),\n                 envir = attr(fit$terms, \".Environment\"))\n  }\n\n  .origdat <- get_all_vars(fit$formula, data = .data)\n\n  if (!is.null(.na.action <- fit$na.action)){\n    .origdata <- do.call(paste0(\"na.\", class(.na.action)),\n                         list(object = .origdata))\n  }\n\n  # refit model for each fit\n  .refit <- function(newy, fit, origdat){\n    origdat[, 1] <- newy\n\n    .newfit <- my_update(fit, paste(colnames(origdat)[1], \" ~ .\"),\n                         data = origdat)\n\n    c(coef(.newfit), sqrt(diag(vcov(.newfit))))\n  }\n\n  .all <- apply(.boot, 2, .refit, fit = fit, origdat = .origdat)\n\n  .ests <- .all[1:length(coef(fit)), , drop = FALSE]\n\n  attr(.ests, \"std.err\") <- .all[-c(1:length(coef(fit))), , drop = FALSE]\n  attr(.ests, \"original.estimates\") <- fit$coefficients\n  attr(.ests, \"original.std.err\") <- sqrt(diag(vcov(fit)))\n\n  .ests\n}",
    "created" : 1528738123306.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2851182795",
    "id" : "4DDBDBE7",
    "lastKnownWriteTime" : 1528740148,
    "last_content_update" : 1528740148951,
    "path" : "C:/Users/Administrator/OneDrive - Rose-Hulman Institute of Technology/Github/IntroAnalysis/R/bootstrap_lm.R",
    "project_path" : "R/bootstrap_lm.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}